export { getApplicativeMonoid } from 'fp-ts/Applicative'
export { getApplySemigroup, sequenceS, sequenceT } from 'fp-ts/Apply'
export * as b from 'fp-ts/boolean'
export * as C from 'fp-ts/Console'
export * as D from 'fp-ts/Date'
export * as E from 'fp-ts/Either'
export * as Endo from 'fp-ts/Endomorphism'
export * as Eq from 'fp-ts/Eq'
export * as F from 'fp-ts/Foldable'
export * as IO from 'fp-ts/IO'
export * as IOE from 'fp-ts/IOEither'
export * as IOR from 'fp-ts/IORef'
export * as J from 'fp-ts/Json'
export * as M from 'fp-ts/Monoid'
export * as n from 'fp-ts/number'
export * as O from 'fp-ts/Option'
export * as Ord from 'fp-ts/Ord'
export * as Ordg from 'fp-ts/Ordering'
export * as P from 'fp-ts/Predicate'
export * as RA from 'fp-ts/ReadonlyArray'
export * as RE from 'fp-ts/ReaderEither'
export * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
export * as RR from 'fp-ts/ReadonlyRecord'
export * as Rr from 'fp-ts/Reader'
export * as RS from 'fp-ts/ReadonlySet'
export * as RT from 'fp-ts/ReaderTask'
export * as RTE from 'fp-ts/ReaderTaskEither'
export * as RTT from 'fp-ts/ReadonlyTuple'
export * as S from 'fp-ts/Semigroup'
export * as s from 'fp-ts/string'
export * as Sd from 'fp-ts/Separated'
export * as st from 'fp-ts/struct'
export * as t from 'io-ts'
export * as tt from 'io-ts-types'
export * as T from 'fp-ts/Task'
export * as TE from 'fp-ts/TaskEither'
export * as v from 'fp-ts/void'
export * from 'fp-ts/function'

export function spy<A>(a: A): A {
  console.log(a)
  return a
}
